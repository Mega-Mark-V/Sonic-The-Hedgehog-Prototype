; ---------------------------------------------------------------------------
; Sonic the Hedgehog (Prototype) Disassembly
; KatKurin 2024
; ---------------------------------------------------------------------------

        include         "_include/Constants.i"
        include         "_include/Mega Drive.i"
        include         "_include/RAM.i"
        include         "_include/Sound.i"
        include         "_include/Variables.i"

; ---------------------------------------------------------------------------   
; Header and initial program
; ---------------------------------------------------------------------------

HEADER:
        dc.l $FFFE00            ; Initial SP
        dc.l SECURITY           ; Initial PC
                
        dc.l ERROR_BUS          ; Error vectors
        dc.l ERROR_ADDRESS
        dc.l ERROR_ILLEGAL
        dc.l ERROR_ZERODIV
        dc.l ERROR_CHKINST
        dc.l ERROR_TRAPV
        dc.l ERROR_PRIVILEGE
        dc.l ERROR_TRACE
        dc.l ERROR_LINEA
        dc.l ERROR_LINEF
 
        dc.l ERROR,ERROR,ERROR,ERROR    ; Reserved (Unused)   
        dc.l ERROR,ERROR,ERROR,ERROR
        dc.l ERROR,ERROR,ERROR,ERROR
        
        dc.l ERROR              ; Spurious Interrupt
        dc.l UINT               ; IRQ1
        dc.l UINT               ; IRQ2 (EXT)
        dc.l UINT               ; IRQ3
        dc.l HBLANK             ; IRQ4 (Horizontal blanking interrupt)
        dc.l UINT               ; IRQ5
        dc.l VBLANK             ; IRQ6 (Vertical blanking interrupt)
        dc.l UINT

        dc.l UINT,UINT,UINT,UINT        ; TRAP Exceptions
        dc.l UINT,UINT,UINT,UINT        ; (Unused)
        dc.l UINT,UINT,UINT,UINT
        dc.l UINT,UINT,UINT,UINT
        
        dc.l UINT,UINT,UINT,UINT        ; Reserved (Unused)
        dc.l UINT,UINT,UINT,UINT
        dc.l UINT,UINT,UINT,UINT
        dc.l UINT,UINT,UINT,UINT
        
; ---------------------------------------------------------------------------
; Game Information (Stock SDK)
; ---------------------------------------------------------------------------

GAME_ID:
                dc.b 'SEGA MEGA DRIVE '
                dc.b '(C)SEGA 1989.JAN'
                dc.b '                        '
                dc.b '                        '
                dc.b 'GM 00000000-00'
CHECKSUM:       dc.w     0              
PERIPHERALS:    dc.b 'J               '
GAMESTART:      dc.l CARTRIDGE
GAMEEND:        dc.l CARTRIDGEE-1
RAMSTART:       dc.l WORKRAM
RAMEND:         dc.l WORKRAME-1
                dc.b '    '
                dc.b '    '
                dc.b '    '
                dc.b '            '
                dc.b '                        '
                dc.b 'JU              '
HEADEREND:

; ---------------------------------------------------------------------------
; Undefined interrupt handler (Stop 68k)
; ---------------------------------------------------------------------------

UINT:
        nop
        nop
        bra.s   UINT

; ---------------------------------------------------------------------------
; ICD_BLK SECURITY Block
; This version is earlier than what is used in the final game
; The final game uses ICD_BLK4.PRG, which is dated June 6th, 1990
; ---------------------------------------------------------------------------

SECURITY:
        tst.l   IOCTRL1_        ; Test controller 1 and 2 bits

.WaitBoot:          
        bne.w   Start   
        tst.w   IOCTRL3_
        bne.s   .WaitBoot
        lea     SECURITYDATA(pc),a5
        movem.l (a5)+,d5-d7/a0-a4
        
        move.w  VERSION_-Z80BUS(a1),d0
        andi.w  #(%1111<<8),d0
        beq.s   .NoTMSS
        move.l  #'SEGA',Z80BUS-TMSSSEGA(a1)

.NoTMSS:              
        move.w  (a4),d0         ; VDP dummy read
        moveq   #0,d0
        movea.l d0,a6           ; Clear a6 and usp
        move.l  a6,usp
        
        moveq   #24-1,d1
.SetVDPRegs:           
        move.b  (a5)+,d5
        move.w  d5,(a4)
        add.w   d7,d5
        dbf     d1,.SetVDPRegs  ; Loop until 0
        
        move.l  #VRAMDMA,(a4)
        move.w  d0,(a3)
        move.w  d7,(a1)
        move.w  d7,(a2)

.WaitForZ80:           
        btst    d0,(a1)
        bne.s   .WaitForZ80
        moveq   #(SECURITY_Z80E-SECURITY_Z80)-1,d2

.LoadZ80Init:          
        move.b  (a5)+,(a0)+
        dbf     d2,.LoadZ80Init
        
        move.w  d0,(a2)
        move.w  d0,(a1)
        move.w  d7,(a2)

.ClrRAM:               
        move.l  d0,-(a6)
        dbf     d6,.ClrRAM
        move.l  #$81048F02,(a4)
        
        ; ^ VREG $81 - %00000100 (M5 Display bit set)
        ;   VREG $8F - $02 (VDP Autoincrement value)
        
        move.l  #CRAMWRITE,(a4) ; Send CRAM write command
        moveq   #32-1,d3

.ClrCRAM:              
        move.l  d0,(a3)
        dbf     d3,.ClrCRAM
        
        move.l  #VSRAMWRITE,(a4)
        moveq   #20-1,d4

.ClrVSRAM:             
        move.l  d0,(a3)
        dbf     d4,.ClrVSRAM
        moveq   #4-1,d5

.PSGInitLoop:          
        move.b  (a5)+,PSGCTRL-VDPDATA(a3)
        dbf     d5,.PSGInitLoop
        move.w  d0,(a2)
        movem.l (a6),d0-d7/a0-a6
        move    #$2700,sr
        bra.s   Start

; ---------------------------------------------------------------------------
; SECURITY Data table
; ---------------------------------------------------------------------------

SECURITYDATA:
        dc.l $8000              ; d5, VDP register offset constant
        dc.l (WORKRAME/4)-1     ; d6, Size of WORKRAM in longwords
        dc.l $100               ; d7, VDP register increment value
        
        dc.l Z80RAM             ; a0
        dc.l Z80BUS             ; a1
        dc.l Z80RES             ; a2
        dc.l VDPDATA            ; a3
        dc.l VDPCTRL            ; a4
        
; ---------------------------------------------------------------------------
; These are not relevant to the actual game program and are only used
; within the security sector
; ---------------------------------------------------------------------------

SECURITY_VDP:
        dc.b %0000100   ; 00 (MODE REG1) Normal color mode           
        dc.b %0010100   ; 01 (MODE REG2) Mode 5 display on, DMA on
        
        dc.b $C000>>10  ; 02 Plane A Nametable Address 
        dc.b $F000>>10  ; 03 Window Nametable Address
        dc.b $E000>>13  ; 04 Plane B Nametable Address
        
        dc.b $D800>>9   ; 05 Sprite Table Address
        dc.b 0          ; 06 *Unused on MD*
        dc.b (0<<4)+0   ; 07 Background color
        dc.b 0          ; 08 *Unused on MD*
        dc.b 0          ; 09 *Unused on MD*
        dc.b 256-1      ; 0A H-BLANK Scanline Interval
        
        dc.b 0          ; 0B (MODE REG3) Scroll fullscreen
        dc.b %10000001  ; 0C (MODE REG4) H40 Cell mode
        
        dc.b $DC00>>10  ; 0D H-Scroll Tablle Address
        dc.b 0          ; 0E *Unused on MD*
        dc.b 1          ; 0F VDP Address Autoincrement value
        dc.b 1          ; 10 Plane size (256x512)
        
        dc.b 0          ; 11 Window Plane Xpos
        dc.b 0          ; 12 Window Plane Ypos
        
        dc.b $FF        ; 13 DMA Length (Low)
        dc.b $FF        ; 14 DMA Length (Hi)
        
        dc.b 0          ; 15 DMA Source (Low)
        dc.b 0          ; 16 DMA Source (Mid)
        dc.b $80        ; 17 DMA Source (Hi)

; ---------------------------------------------------------------------------
; Z80 dummy program
; ---------------------------------------------------------------------------

SECURITY_Z80:
        dc.b $AF,  1,$D7,$1F
        dc.b $11,$29,  0,$21
        dc.b $28,  0,$F9,$77
        dc.b $ED,$B0,$DD,$E1
        dc.b $FD,$E1,$ED,$47
        dc.b $ED,$4F,  8,$D9
        dc.b $F1,$C1,$D1,$E1
        dc.b   8,$D9,$F1,$D1
        dc.b $E1,$F9,$F3,$ED
        dc.b $56,$36,$E9,$E9
SECURITY_Z80E:

; ---------------------------------------------------------------------------

SECURITY_PSG:   dc.b $9F,$BF,$DF,$FF

; ---------------------------------------------------------------------------
; Game program start
; ---------------------------------------------------------------------------

Start:          
        btst    #%110,IOCTRL3
        beq.s   .ForceColdBoot
        cmpi.l  #'init',bootFlag.w
        beq.w   .WarmBoot

.ForceColdBoot:        
        movea.l #HeaderEnd,a0   ; Get header end location
        movea.l #GAMEEND,a1     ; Get the catalogued ROM end location
        move.l  (a1),d0
        moveq   #0,d1

.CalculateChkSum:              
        add.w   (a0)+,d1         ; Add up all words into d1
        cmp.l   a0,d0            ;  
        bcc.s   .CalculateChkSum ; If not, continue the loop
        movea.l #CHECKSUM,a1     ; Compare against the catalogued checksum value
        cmp.w   (a1),d1

        nop     ; <- bne.w ChecksumFailed
        nop

        lea     stack.w,a6
        moveq   #0,d7
        move.w  #($200/4)-1,d6  ; Clear previous game information
.ClearGameVars:        
        move.l  d7,(a6)+
        dbf     d6,.ClearGameVars

        move.b  VERSION,d0
        andi.b  #%11000000,d0
        move.b  d0,hardwareVersion.w
        move.w  #1,levelselectFlag.w
        move.l  #'init',bootFlag.w

.WarmBoot:             
        lea     WORKRAM,a6
        moveq   #0,d7
        move.w  #($FE00/4)-1,d6 ; Clear most of RAM up to 0xFE00
.ClearRAM:             
        move.l  d7,(a6)+
        dbf     d6,.ClearRAM

        bsr.w   InitVDP
        bsr.w   InitSound
        bsr.w   InitJoypads
        move.b  #0,gamemode.w

Main:           
        move.b  gamemode.w,d0
        andi.w  #6*4,d0                         ; Cap to 7 modes (2 unimplemented)
        jsr     .Index(pc,d0.w)
        bra.s   Main
        
; ---------------------------------------------------------------------------

.Index:        
        bra.w   GM_LOGO                 ; SEGA Logo program (Standard)
        bra.w   GM_TITLE                ; Title Screen
        bra.w   GM_LEVEL                ; Demo
        bra.w   GM_LEVEL                ; Level
        bra.w   GM_SPECIAL              ; Special Stage
                                        ; Ending sequence (unimplemented)
                                        ; Continue screen (unimplemented)
        rts

; --------------------------------------------------------------------------- 

gmID_LOGO               EQU         0*4 ; *4 for jumptable entry
gmID_TITLE              EQU         1*4 ; !!! Do something better for this.
gmID_DEMO               EQU         2*4
gmID_LEVEL              EQU         3*4
gmID_SPECIAL            EQU         4*4

; ---------------------------------------------------------------------------
; Checksum Failure routine (unused)
; ---------------------------------------------------------------------------
   
; ??CheckSumFailed:
        bsr.w   InitVDP
        move.l  #CRAMWRITE,VDPCTRL
        moveq   #64-1,d7

.FillCRAM:                     
        move.w  #$00E,VDPDATA
        dbf     d7,.FillCRAM

.Stop68K:                      
        bra.s   .Stop68K
        
; ---------------------------------------------------------------------------

        include  "Error Handler.68k"

; ---------------------------------------------------------------------------


        
; ---------------------------------------------------------------------------

ArtUnc_Text:    incbin  "ArtUnc/Generic Text.unc"
ArtUnc_TextE:
ArtUnc_TextSZ   EQU     ArtUnc_TextE-ArtUnc_Text

; ---------------------------------------------------------------------------

vbID_NULL           EQU         0*2  ; !!! Do something better here.
vbID_LOGO           EQU         1*2
vbID_TITLE          EQU         2*2
vbID_UNK            EQU         3*2
vbID_LEVEL          EQU         4*2
vbID_SPECIAL        EQU         5*2
vbID_LVLSTART       EQU         6*2
vbID_TIMER          EQU         7*2
vdID_PAUSE          EQU         8*2
vbID_PALFUNC        EQU         9*2

; ---------------------------------------------------------------------------

VBLANK:                                 
        movem.l d0-d7/a0-a6,-(sp)
        tst.b   vblankCmd.w           ; If no command given, exit
        beq.s   .End
        move.w  VDPCTRL,d0
        move.l  #VSRAMWRITE,VDPCTRL
        move.l  vdpPlaneAPosY.w,VDPDATA

        btst    #6,hardwareVersion.w  ; Get hardware region
        beq.s   .NTSC                 ; Skip if NTSC
        move.w  #$700,d0              ; Wait for PAL timing               
        dbf     d0,*                    
.NTSC:                                 
        move.b  vblankCmd.w,d0        ; Get user command
        move.b  #0,vblankCmd.w        ; Clear command variable
        move.w  #1,hblankFlag.w       ; Reset the HBLANK exec. flag
        andi.w  #%111110,d0
        move.w  .Index(pc,d0.w),d0    ; Jump to execution
        jsr     .Index(pc,d0.w)

.End:                                  
        addq.l  #1,vblankCounter.w
        jsr     UpdateMusic
        movem.l (sp)+,d0-d7/a0-a6
        rte

; ---------------------------------------------------------------------------

.NULL                                
        rts

; ---------------------------------------------------------------------------

.Index:                                
                dc.w .NULL-.Index                       ; 0
                dc.w VBLANK_LOGO-.Index                 ; 2
                dc.w VBLANK_TITLE-.Index                ; 4
                dc.w VBLANK_UNK-.Index                  ; 6
                dc.w VBLANK_LEVEL-.Index                ; 8
                dc.w VBLANK_SPECIAL-.Index              ; A
                dc.w VBLANK_LVLSTART-.Index             ; C
                dc.w VBLANK_TIMER-.Index                ; E
                dc.w VBLANK_PAUSE-.Index                ; 10
                dc.w VBLANK_PALFUNC-.Index              ; 12

; ---------------------------------------------------------------------------
; LOGO / SEGA Screen routine
; ---------------------------------------------------------------------------

VBLANK_LOGO:                                
        bsr.w   RefreshVDPBuffers
        tst.w   genericTimer.w
        beq.w   .Exit
        subq.w  #1,genericTimer.w

.Exit:                             
        rts

; ---------------------------------------------------------------------------
; TITLE Screen routine
; ---------------------------------------------------------------------------

VBLANK_TITLE:                               
        bsr.w   RefreshVDPBuffers
        bsr.w   ProcessBGScrollingTiles
        bsr.w   DecompArtList_Fast
        tst.w   genericTimer.w
        beq.w   .Exit
        subq.w  #1,genericTimer.w

.Exit:                             
        rts

; ---------------------------------------------------------------------------
; Unknown basic routine
; ---------------------------------------------------------------------------

VBLANK_UNK:                               
        bsr.w   RefreshVDPBuffers
        rts

; ---------------------------------------------------------------------------
; PAUSE routine
; ---------------------------------------------------------------------------

VBLANK_PAUSE:                               
        cmpi.b  #gmID_SPECIAL,gamemode.w
        beq.w   VBLANK_SPECIAL

; ---------------------------------------------------------------------------
; LEVEL main routine (Post-load, when in level gameplay)
; ---------------------------------------------------------------------------

VBLANK_LEVEL:                           
        bsr.w   ReadJoypads
        move.w  #$100,Z80BUS

.WaitZ80:                              
        btst    #0,Z80BUS
        bne.s   .WaitZ80

        VDPDMA  palette,$0000,$80,CRAM,a5     ; Palette DMA
        VDPDMA  hscroll,$FC00,$380,VRAM,a5    ; Hscroll DMA

        move.w  #$8407,a5
        move.w  vdpHBLANKLine.w,a5
        move.w  vdpPlaneZPosY.w,vdpPlaneZPosY2.w

        VDPDMA  sprites,$F800,$280,VRAM,a5    ; Sprite DMA

        tst.b   sonicRedrawFlag.w
        beq.s   .NoSonicRedraw

        VDPDMA  sonicDMABuffer,$F000,$2E0,VRAM,a5 ; Sonic art DMA

        move.b  #0,sonicRedrawFlag.w

.NoSonicRedraw:                                
        move.w  #0,Z80BUS

        bsr.w   ProcessScrollingTiles
        jsr     AnimatedLevelGFX
        jsr     UpdateHUD
        bsr.w   DecompArtList_Slow

        moveq   #0,d0
        move.b  vblankUnk1.w,d0
        move.b  vblankUnk2.w,d1
        cmp.b   d0,d1
        bcc.s   .Skip
        move.b  d0,vblankUnk2.w

.Skip:                                
        move.b  #0,vblankUnk1.w
        tst.w   genericTimer.w
        beq.w   .Exit
        subq.w  #1,genericTimer.w

.Exit:                             
        rts


; ---------------------------------------------------------------------------
; SPECIAL stage routine
; ---------------------------------------------------------------------------

VBLANK_SPECIAL:                             
        bsr.w   ReadJoypads
        move.w  #$100,Z80BUS

.WaitZ80:                                
        btst    #0,Z80BUS
        bne.s   .WaitZ80

        VDPDMA  palette,$0000,$80,CRAM,a5     ; Palette DMA
        VDPDMA  sprites,$F800,$280,VRAM,a5    ; Sprite DMA
        VDPDMA  hscroll,$FC00,$380,VRAM,a5    ; Hscroll DMA

        move.w  #0,Z80BUS
        bsr.w   _specialstgPalCyc

        tst.b   sonicRedrawFlag.w
        beq.s   .NoSonicRedraw

        VDPDMA  sonicDMABuffer,$F000,$2E0,VRAM,a5 ; Sonic art DMA

        move.b  #0,sonicRedrawFlag.w

.NoSonicRedraw:                                
        tst.w   genericTimer.w
        beq.w   .TimerDone
        subq.w  #1,genericTimer.w

.TimerDone:                             
        rts


; ---------------------------------------------------------------------------
; LEVEL starting routine
; ---------------------------------------------------------------------------

VBLANK_LVLSTART:                          
        bsr.w   ReadJoypads
        move.w  #$100,Z80BUS

.WaitZ80:                              
        btst    #0,Z80BUS
        bne.s   .WaitZ80
        VDPDMA  palette,$0000,$80,CRAM,a5               ; Palette DMA
        VDPDMA  sprites,$F800,$280,VRAM,a5              ; Sprite DMA
        VDPDMA  hscroll,$FC00,$380,VRAM,a5              ; Hscroll DMA
        tst.b   sonicRedrawFlag.w
        beq.s   .NoSonicRedraw
        VDPDMA  sonicDMABuffer,$F000,$2E0,VRAM,a5       ; Sonic art DMA
        move.b  #0,sonicRedrawFlag.w

.NoSonicRedraw:                        
        move.w  #0,Z80BUS
        bsr.w   ProcessScrollingTiles
        jsr     AnimatedLevelGFX
        jsr     UpdateHUD
        bsr.w   DecompArtList_Fast
        rts

; ---------------------------------------------------------------------------
; Unused routine that increments a timer. 
; Pieces of it remain above in VBLANK_LEVEL. Usage unknown.
; ---------------------------------------------------------------------------

VBLANK_TIMER:                                 
        bsr.w   RefreshVDPBuffers
        bsr.w   RunObjects
        bsr.w   DrawObjects
        addq.b  #1,(vblankUnk1).w
        move.b  #vbID_TIMER,(vblankCmd).w
        rts

; ---------------------------------------------------------------------------
; Idle routine for palette functions, like fading in and out
; ---------------------------------------------------------------------------

VBLANK_PALFUNC:                             
        bsr.w   RefreshVDPBuffers
        bra.w   DecompArtList_Fast

; ---------------------------------------------------------------------------
; Refresh VDP tile/sprite data with most recent buffer data in memory
; ---------------------------------------------------------------------------

RefreshVDPBuffers:                      
        bsr.w   ReadJoypads
        move.w  #$100,Z80BUS

.WaitZ80:                              
        btst    #0,Z80BUS
        bne.s   .WaitZ80

        VDPDMA  palette,$0000,$80,CRAM,a5     ; Palette DMA
        VDPDMA  sprites,$F800,$280,VRAM,a5    ; Sprite DMA
        VDPDMA  hscroll,$FC00,$380,VRAM,a5    ; Hscroll DMA

        move.w  #0,Z80BUS
        rts

; ---------------------------------------------------------------------------
; HBLANK 
; Early implementation of the water mid-screen palette swap, which uses DMA
; The final game uses manual writes to VDPDATA which is quicker
; due to requiring less setup
; ---------------------------------------------------------------------------


HBLANK:                                 
        tst.w   hblankFlag.w
        beq.s   .Exit
        move.l  a5,-(sp)
        VDPDMA  palFadeBuffer,$0000,$80,CRAM,a5  ; Palette DMA
        movem.l (sp)+,a5
        move.w  #0,hblankFlag.w                  ; Set as executed

.Exit:                                 
        rte

; ---------------------------------------------------------------------------
; Unused earlier HBLANK routine
; This swaps the background nametable and rewrites the sprite table
; This was likely intended for either parallax or water effects
; ---------------------------------------------------------------------------

UNUSED_HBLANK2:
        tst.w   hblankFlag.w
        beq.s   .Exit
        movem.l d0/a0/a5,-(sp)
        move.w  #0,hblankFlag.w
        move.w  #$8405,VDPCTRL
        move.w  #$857C,VDPCTRL
        move.l  #$78000003,VDPCTRL
        lea     vdpSprites.w,a0
        lea     VDPDATA,a5
        move.w  #$A0-1,d0

.WriteSprites:                         
        move.l  (a0)+,(a5)
        dbf     d0,.WriteSprites
        movem.l (sp)+,d0/a0/a5
.Exit:                                 
        rte

; ---------------------------------------------------------------------------
; Prepare to read joypad IO ports
; ---------------------------------------------------------------------------

InitJoypads:                            
        move.w  #$100,Z80BUS

.WaitZ80:                              
        btst    #0,Z80BUS
        bne.s   .WaitZ80
        moveq   #$40,d0
        move.b  d0,IOCTRL1
        move.b  d0,IOCTRL2
        move.b  d0,IOCTRL3
        move.w  #0,Z80BUS
        rts

; ---------------------------------------------------------------------------
; Read joypad IO ports
; Common SACBRLDU scheme (1 bit per button for 8 bits)
; ---------------------------------------------------------------------------

ReadJoypads:                            
        move.w  #$100,Z80BUS

.WaitZ80:                              
        btst    #0,Z80BUS
        bne.s   .WaitZ80

        lea     joypad.w,a0     ; Set output location
        lea     IODATA1,a1
        bsr.s   .ReadPad
        addq.w  #2,a1           ; (IODATA1)+2 = IODATA2
        bsr.s   .ReadPad

        move.w  #0,Z80BUS
        rts

.ReadPad:                              
        move.b  #0,(a1)         ; Get first frame bits (Start+A)    
        nop                     ; Wait a bit for the I/O control chip
        nop
        move.b  (a1),d0         ; Read bits
        lsl.b   #2,d0           ; Move them to bits 6 and 7
        andi.b  #%11000000,d0   ; Clear bits 0-5

        move.b  #$40,(a1)       ; Get second frame bits (everything else)
        nop
        nop
        move.b  (a1),d1
        andi.b  #%00111111,d1   ; Clear top 2 bits
        or.b    d1,d0           ; Combine them into d0
        not.b   d0              ; Invert bit scheme (0 = not pressed)

        move.b  (a0),d1         ; Get previous controller read
        eor.b   d0,d1
        move.b  d0,(a0)+        ; Calculate "pressed" from "held"
        and.b   d0,d1
        move.b  d1,(a0)+        
        rts

; ---------------------------------------------------------------------------
; Basic VDP initialization/setup routine
; ---------------------------------------------------------------------------

InitVDP:                                
        lea     VDPCTRL,a0
        lea     VDPDATA,a1
        lea     @VDPInitValues,a2
        moveq   #$13-1,d7

.WriteRegs:                            
        move.w  (a2)+,(a0)
        dbf     d7,.WriteRegs
        move.w  @VDPInitValues+2,d0
        move.w  d0,vdpBuffer.w
        moveq   #0,d0
        move.l  #CRAMWRITE,VDPCTRL
        move.w  #64-1,d7

.ClearCRAM:                            
        move.w  d0,(a1)
        dbf     d7,.ClearCRAM
        clr.l   vdpPlaneAPosY.w
        clr.l   vdpPlaneAPosX.w
        move.l  d1,-(sp)
        VDPFILL $0000,$1FFFE,$00,1,a6
        move.w  #$8F02,(a5)
        move.l  (sp)+,d1
        rts

; ---------------------------------------------------------------------------

@VDPInitValues:  
        dc.w $8004              
        dc.w $8134
        dc.w $8230
        dc.w $8328
        dc.w $8407
        dc.w $857C
        dc.w $8600
        dc.w $8700
        dc.w $8800
        dc.w $8900
        dc.w $8A00
        dc.w $8B00
        dc.w $8C81
        dc.w $8D3F
        dc.w $8E00
        dc.w $8F02
        dc.w $9001
        dc.w $9100
        dc.w $9200

; ---------------------------------------------------------------------------


InitScreen:
        VDPFILL $C000,$1FFE,$00,1,a5    ; Clear plane A nametable
        move.w  #$8F02,(a5)
        VDPFILL $E000,$1FFE,$00,1,a5    ; Clear plane B nametable
        move.w  #$8F02,(a5)
        move.l  #0,vdpPlaneAPosY.w
        move.l  #0,vdpPlaneAPosX.w

        lea     vdpSprites.w,a1
        moveq   #0,d0
        move.w  #$A0-1,d1               ; ???

.ClearSprites:
        move.l  d0,(a1)+
        dbf     d1,.ClearSprites
        lea     hscrollTable.w,a1
        moveq   #0,d0
        move.w  #$100,d1

.ClearHScroll:
        move.l  d0,(a1)+
        dbf     d1,.ClearHScroll
        rts

; ---------------------------------------------------------------------------

InitSound:
        nop
        move.w  #$100,Z80BUS
        move.w  #$100,Z80RES
        lea     Z80_SOUND_ROM        ; !!! Needs new name?
        lea     Z80RAM,a1
        move.w  #$1C5B,d0            ; !!! Get size later

.WriteToZ80RAM:
        move.b  (a0)+,(a1)+
        dbf     d0,.WriteToZ80RAM
        moveq   #0,d0
        lea     $A01FF8,a1           ; !!! obvious
        move.b  d0,(a1)+
        move.b  #$80,(a1)+
        move.b  #7,(a1)+
        move.b  #$80,(a1)+
        move.b  d0,(a1)+
        move.b  d0,(a1)+
        move.b  d0,(a1)+
        move.b  d0,(a1)+
        move.w  #0,Z80RES
        nop
        nop
        nop
        nop
        move.w  #$100,Z80RES
        move.w  #0,Z80BUS
        rts

; ---------------------------------------------------------------------------
; Driver Init. data leftover from an earlier implementation
; ---------------------------------------------------------------------------
                dc.b   3
                dc.b   0
                dc.b   0
                dc.b $14
                dc.b   0
                dc.b   0
                dc.b   0
                dc.b   0

; ---------------------------------------------------------------------------
; Routines that simply poke sound queues
; Queue A is used for music most of the time, B for sounds. C is unused.
; ---------------------------------------------------------------------------

QueueSoundA:
        move.b  d0,soundqueueA.w
        rts

; ---------------------------------------------------------------------------


QueueSoundB:
        move.b  d0,soundqueueB.w
        rts

; ---------------------------------------------------------------------------

QueueSoundC:
        move.b  d0,soundqueueC.w
        rts

; ---------------------------------------------------------------------------

PauseGame:
        nop
        tst.b   lives.w
        beq.s   .Dead
        tst.w   paused.w
        bne.s   .Paused
        btst    #7,joypadPress.w
        beq.s   .Exit

.Paused:
        move.w  #-1,(paused).w

loc_11D2:                               
        move.b  #vbID_PAUSE,(vblankCmd).w
        bsr.w   VSync
        btst    #%110,(joypadPress).w
        beq.s   .ABtnNotPressed
        move.b  #gmID_TITLE,(gamemode).w
        nop
        bra.s   .Dead

; ---------------------------------------------------------------------------

.ABtnNotPressed:                       
        btst    #%100,joypad.w
        bne.s   loc_120E
        btst    #%101,joypadPress.w
        bne.s   loc_120E
        btst    #%111,joypadPress.w
        beq.s   loc_11D2

.Dead:                                 
        move.w  #0,paused.w

.Exit:                                 
        rts
; ---------------------------------------------------------------------------

loc_120E:                               
        move.w  #1,paused.w
        rts

; ---------------------------------------------------------------------------
; Function to draw a basic tilemap
; ---------------------------------------------------------------------------
; PARAMETERS:
;       a1 - Tilemap data address
;       d0 - VDP command
;       d1 - (Width)-1
;       d2 - (Height)-1
; ---------------------------------------------------------------------------

DrawTileMap:                            
        lea     VDPDATA,a6
        move.l  #$800000,d4

.LoopRow:                              
        move.l  d0,VDPCTRL-VDPDATA(a6)
        move.w  d1,d3

.LoopColumn:                           
        move.w  (a1)+,(a6)
        dbf     d3,.LoopColumn
        add.l   d4,d0
        dbf     d2,.LoopRow
        rts

; -------------------------------------------------------------------------
; Decompress Nemesis data into RAM 
; (Documentation taken from Sonic CD Disassembly)
; ---------------------------------------------------------------------------
; PARAMETERS:
;       a0 - Nemesis data pointer
;       a4 - Destination if decompressing to RAM
; ---------------------------------------------------------------------------

NemDec:
        movem.l d0-a1/a3-a5,-(sp)
        lea     NemPCD_WriteRowToVDP,a3         ; Write all data to the same location
        lea     VDPDATA,a4                      ; VDP data port
        bra.s   NemDecMain

.ToRAM:
        movem.l d0-a1/a3-a5,-(sp)
        lea     NemPCD_WriteRowToRAM,a3         ; Advance to the next location after each write

; ---------------------------------------------------------------------------

NemDecMain:
        lea     globalBuffer.w,a1               ; Prepare decompression buffer
        move.w  (a0)+,d2                        ; Get number of patterns
        lsl.w   #1,d2
        bcc.s   .NormalMode                     ; Branch if not in XOR mode
        adda.w  #NemPCD_WriteRowToVDP_XOR-NemPCD_WriteRowToVDP,a3

.NormalMode:
        lsl.w   #2,d2                           ; Get number of 8-pixel rows in the uncompressed data
        movea.w d2,a5                           ; and store it in a5
        moveq   #8,d3                           ; 8 pixels in a pattern row
        moveq   #0,d2
        moveq   #0,d4
        bsr.w   NemDec_BuildCodeTable
        move.b  (a0)+,d5                        ; Get first word of compressed data
        asl.w   #8,d5
        move.b  (a0)+,d5
        move.w  #16,d6                          ; Set initial shift value
        bsr.s   NemDec_ProcessCompressedData
        movem.l (sp)+,d0-a1/a3-a5
        rts

; ---------------------------------------------------------------------------

NemDec_ProcessCompressedData:
        move.w  d6,d7
        subq.w  #8,d7                           ; Get shift value
        move.w  d5,d1
        lsr.w   d7,d1                           ; Shift so that the high bit of the code is in bit 7
        cmpi.b  #%11111100,d1                   ; Are the high 6 bits set?
        bcc.s   NemPCD_InlineData               ; If they are, it signifies inline data
        andi.w  #$FF,d1
        add.w   d1,d1
        move.b  (a1,d1.w),d0                    ; Get the length of the code in bits
        ext.w   d0
        sub.w   d0,d6                           ; Subtract from shift value so that the next code is read next time around
        cmpi.w  #9,d6                           ; Does a new byte need to be read?
        bcc.s   .GotEnoughBits                  ; If not, branch
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5                        ; Read next byte

.GotEnoughBits:
        move.b  1(a1,d1.w),d1
        move.w  d1,d0
        andi.w  #$F,d1                          ; Get palette index for pixel
        andi.w  #$F0,d0

NemDec_GetRunLength:
        lsr.w   #4,d0                           ; Get repeat count

NemDec_RunLoop:
        lsl.l   #4,d4                           ; Shift up by a nibble
        or.b    d1,d4                           ; Write pixel
        subq.w  #1,d3                           ; Has an entire 8-pixel row been written?
        bne.s   NemPCD_WritePixel_Loop          ; If not, loop
        jmp     (a3)                            ; Otherwise, write the row to its destination

; ---------------------------------------------------------------------------

NemPCD_NewRow:
        moveq   #0,d4           ; Reset row
        moveq   #8,d3           ; Reset nibble counter

NemPCD_WritePixel_Loop:
        dbf     d0,NemDec_RunLoop
        bra.s   NemDec_ProcessCompressedData

; ---------------------------------------------------------------------------

NemPCD_InlineData:
        subq.w  #6,d6           ; 6 bits needed to signal inline data
        cmpi.w  #9,d6
        bcc.s   .GotEnoughBits
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5

.GotEnoughBits:
        subq.w  #7,d6           ; And 7 bits needed for the inline data itself
        move.w  d5,d1
        lsr.w   d6,d1           ; Shift so that the low bit of the code is in bit 0
        move.w  d1,d0
        andi.w  #$F,d1          ; Get palette index for pixel
        andi.w  #$70,d0         ; High nibble is repeat count for pixel
        cmpi.w  #9,d6
        bcc.s   NemDec_GetRunLength
        addq.w  #8,d6
        asl.w   #8,d5
        move.b  (a0)+,d5
        bra.s   NemDec_GetRunLength

; ---------------------------------------------------------------------------

NemPCD_WriteRowToVDP:
        move.l  d4,(a4)         ; Write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4           ; Have all the 8-pixel rows been written?
        bne.s   NemPCD_NewRow   ; If not, branch
        rts

; ---------------------------------------------------------------------------

NemPCD_WriteRowToVDP_XOR:
        eor.l   d4,d2           ; XOR the previous row with the current row
        move.l  d2,(a4)                         ; and store it
        subq.w  #1,a5
        move.w  a5,d4           ; Have all the 8-pixel rows been written?
        bne.s   NemPCD_NewRow   ; If not, branch
        rts

; ---------------------------------------------------------------------------

NemPCD_WriteRowToRAM:
        move.l  d4,(a4)+        ; Write 8-pixel row
        subq.w  #1,a5
        move.w  a5,d4           ; Have all the 8-pixel rows been written?
        bne.s   NemPCD_NewRow   ; If not, branch
        rts

; ---------------------------------------------------------------------------

NemPCD_WriteRowToRAM_XOR:
        eor.l   d4,d2           ; XOR the previous row with the current row
        move.l  d2,(a4)+        ; and store it
        subq.w  #1,a5
        move.w  a5,d4           ; Have all the 8-pixel rows been written?
        bne.s   NemPCD_NewRow   ; If not, branch
        rts

; ---------------------------------------------------------------------------

NemDec_BuildCodeTable:
        move.b  (a0)+,d0                        ; Read first byte

NemBCT_ChkEnd:
        cmpi.b  #$FF,d0                         ; Has the end of the code table description been reached?
        bne.s   NemBCT_NewPalIndex              ; If not, branch
        rts

NemBCT_NewPalIndex:
        move.w  d0,d7

NemBCT_Loop:
        move.b  (a0)+,d0                        ; Read next byte
        cmpi.b  #$80,d0                         ; Sign bit signifies a new palette index
        bcc.s   NemBCT_ChkEnd

        move.b  d0,d1
        andi.w  #$F,d7                          ; Get palette index
        andi.w  #$70,d1                         ; Get repeat count for palette index
        or.w    d1,d7                           ; Combine the 2
        andi.w  #$F,d0                          ; Get the length of the code in bits
        move.b  d0,d1
        lsl.w   #8,d1
        or.w    d1,d7                           ; Combine with palette index and repeat count to form code table entry
        moveq   #8,d1
        sub.w   d0,d1                           ; Is the code 8 bits long?
        bne.s   NemBCT_ShortCode                ; If not, a bit of extra processing is needed
        move.b  (a0)+,d0                        ; Get code
        add.w   d0,d0                           ; Each code gets a word sized entry in the table
        move.w  d7,(a1,d0.w)                    ; Store the entry for the code

        bra.s   NemBCT_Loop                     ; Loop

NemBCT_ShortCode:
        move.b  (a0)+,d0                        ; Get code
        lsl.w   d1,d0                           ; Get index into code table
        add.w   d0,d0                           ; Shift so that the high bit is in bit 7
        moveq   #1,d5
        lsl.w   d1,d5
        subq.w  #1,d5                           ; d5 = 2^d1 - 1

NemBCT_ShortCode_Loop:
        move.w  d7,(a1,d0.w)                    ; Store entry
        addq.w  #2,d0                           ; Increment index
        dbf     d5,NemBCT_ShortCode_Loop        ; Repeat for required number of entries

        bra.s   NemBCT_Loop                     ; Loop

; ---------------------------------------------------------------------------
; Load an art list (known as "PLCs" elsewhere)
; ---------------------------------------------------------------------------
; PARAMETERS:
;       d0.w - Artlist ID
; ---------------------------------------------------------------------------

LoadArtList:                         
        movem.l a1-a2,-(sp)

        lea     ArtListIndex,a1
        add.w   d0,d0
        move.w  (a1,d0.w),d0
        lea     (a1,d0.w),a1
        lea     decompQueue.w,a2

.Loop:                                 
        tst.l   (a2)
        beq.s   .FoundFree
        addq.w  #6,a2
        bra.s   .Loop

.FoundFree:                            
        move.w  (a1)+,d0
        bmi.s   .End

.Load:                                 
        move.l  (a1)+,(a2)+
        move.w  (a1)+,(a2)+
        dbf     d0,.Load

.End:                                  
        movem.l (sp)+,a1-a2

        rts


; ---------------------------------------------------------------------------
; Clear any existing queue entries and initialize with a new art list
; ---------------------------------------------------------------------------
; PARAMETERS:
;       d0.w - Artlist ID
; ---------------------------------------------------------------------------

InitArtList:                           
        movem.l a1-a2,-(sp)
        lea     ArtListIndex,a1
        add.w   d0,d0
        move.w  (a1,d0.w),d0
        lea     (a1,d0.w),a1
        bsr.s   ClearArtListQueue
        lea     decompQueue.w,a2
        move.w  (a1)+,d0
        bmi.s   .End

.Load:                               
        move.l  (a1)+,(a2)+
        move.w  (a1)+,(a2)+
        dbf     d0,.Load

.End:                               
        movem.l (sp)+,a1-a2
        rts


; ---------------------------------------------------------------------------
; Clear the art list queue
; ---------------------------------------------------------------------------

ClearArtListQueue:                      
        lea     decompQueue.w,a2
        moveq   #32-1,d0

.Loop:                                 
        clr.l   (a2)+
        dbf     d0,.Loop
        rts

; ---------------------------------------------------------------------------
; Process any entries in the art list decompression queue
; ---------------------------------------------------------------------------

ProcessArtLoading:                      
        tst.l   decompQueue.w
        beq.s   .End

        tst.w   decompTileCount.w
        bne.s   .End

        movea.l decompQueue.w,a0
        lea     NemPCD_WriteRowToVDP,a3
        lea     globalBuffer.w,a1
        move.w  (a0)+,d2
        bpl.s   .NotXOR
        adda.w  #NemPCD_WriteRowToVDP_XOR-NemPCD_WriteRowToVDP,a3

.NotXOR:                               
        andi.w  #$7FFF,d2
        move.w  d2,decompTileCount.w

        bsr.w   NemDec_BuildCodeTable

        move.b  (a0)+,d5
        asl.w   #8,d5
        move.b  (a0)+,d5
        moveq   #16,d6

        moveq   #0,d0
        move.l  a0,decompQueue.w
        move.l  a3,decompNemWrite.w
        move.l  d0,decompRepeat.w
        move.l  d0,decompPixel.w
        move.l  d0,decompRow.w
        move.l  d5,decompRead.w
        move.l  d6,decompShift.w

.End:                                  
        rts

; ---------------------------------------------------------------------------
; Decompress an art list
; The user defines whether it's fast or slow on their end
; ---------------------------------------------------------------------------

DecompArtList:

.Fast                     
        tst.w   decompTileCount.w
        beq.w   .Done

        move.w  #9,decompProcTileCnt.w
        moveq   #0,d0
        move.w  decompQueue+4.w,d0
        addi.w  #9*32,decompQueue+4.w
        bra.s   .Main

; ---------------------------------------------------------------------------

.Slow:                     
        tst.w   decompTileCount.w
        beq.s   .Done
        move.w  #3,decompProcTileCnt.w
        moveq   #0,d0
        move.w  decompQueue+4.w,d0
        addi.w  #$60,decompQueue+4.w
.Main:                               
        lea     VDPCTRL,a4
        lsl.l   #2,d0
        lsr.w   #2,d0
        ori.w   #$4000,d0
        swap    d0
        move.l  d0,(a4)
        subq.w  #4,a4
        movea.l decompQueue.w,a0
        movea.l decompNemWrite.w,a3
        move.l  decompRepeat.w,d0
        move.l  decompPixel.w,d1
        move.l  decompRow.w,d2
        move.l  decompRead.w,d5
        move.l  decompShift.w,d6
        lea     globalBuffer.w,a1

.Decomp:                               
        movea.w #8,a5
        bsr.w   NemPCD_NewRow
        subq.w  #1,decompTileCount.w
        beq.s   .Pop
        subq.w  #1,decompProcTileCnt.w
        bne.s   .Decomp
        move.l  a0,decompQueue.w
        move.l  a3,decompNemWrite.w
        move.l  d0,decompRepeat.w
        move.l  d1,decompPixel.w
        move.l  d2,decompRow.w
        move.l  d5,decompRead.w
        move.l  d6,decompShift.w

.Done:                            
        rts

; ---------------------------------------------------------------------------

.Pop:                               
        lea     decompQueue.w,a0
        moveq   #$15,d0

.Loop:                                  
        move.l  6(a0),(a0)+
        dbf     d0,.Loop
        rts

; ---------------------------------------------------------------------------
; Decompress an art list immediately 
; ---------------------------------------------------------------------------

LoadArtListImm:                         
        lea     ArtListIndex,a1
        add.w   d0,d0
        move.w  (a1,d0.w),d0
        lea     (a1,d0.w),a1
        move.w  (a1)+,d1

.Load:                                 
        movea.l (a1)+,a0
        moveq   #0,d0
        move.w  (a1)+,d0
        lsl.l   #2,d0
        lsr.w   #2,d0
        ori.w   #$4000,d0
        swap    d0
        move.l  d0,VDPCTRL
        bsr.w   NemDec
        dbf     d1,.Load
        rts